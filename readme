				myshell使用手册
第一部分 概述
	本myshell使用c语言开发，调用了各类Linux的api，尽力模仿bash的各类功能。
	本使用手册将分为以下部分进行叙述：
	（1）所支持的内部指令与（如果有的话）支持的选项;
	（2）所支持的进阶操作（如管道等）;
	（3）myshell的实现原理（阅读本章节将能让进阶读者更好的使用myshell）。
	注意事项：在开始使用myshell之前，请将本手册复制到一个叫做readme的文本文件中并且与myshell的执行程序放在同一目录下，否则会报错。
第二部分 支持的内部指令
	（1）cd指令：
	描述：本指令将切换当前的工作目录至用户指定的目录，本指令没有附加选项。
	例：cd .. 将返回至上一级目录，cd /bin 则将会将工作目录切换至/bin。
	名词解释：工作目录。工作目录即当前你所处的目录位置，下文将会提到的各种指令如pwd等都将会使用当前工作目录位置作为参数执行，
	
	（2）clr指令：
	描述：本指令将会清空终端的屏幕。然而细心的读者会发现如果在clr执行后，将屏幕向上拉，会发现本指令并没有真正的将终端屏幕原有显示的信息删除，而仅仅是输出一个换行符后再输出一个控制符，使得终端当前的光标回到屏幕的最上面的一行。这模仿了bash的行为，而且Linux似乎并没有提供相应的API能进行真正意义上的清屏。
	
	（3）dir指令：
	描述：本指令将会列出当前工作目录下的所有文件（非隐藏文件）。

	（4）echo指令：
	描述：本指令将会在终端上显示指定的字符串或者变量。（本指令涉及命令替换的部分功能与变量赋值的部分功能，但是在本小节只会给出例子，详细内容若想要了解请翻阅下一大章节）
	例1：	echo string
		输出：string
	例2：	abc=1
		echo $abc
		输出：1
	
	（5）environ指令：
	描述：本指令将列出当前myshell下的所有环境变量，以供使用者查看。
	
	（6）exec指令：
	描述：本指令将执行用户所想要执行的程序。本指令执行完外部程序后将直接退出终端。

	（7）exit：
	描述：本指令将退出myshell。

	（8）pwd指令：
	描述：本指令将会列出当前工作目录的绝对路径。
	名词解释：绝对路径。在bash中，绝对路径可以理解为完整路径，而相对路径可以理解为缩略路径（但是在本myshell中，并没有实现缩略路径，还请注意）。
	举例说明则将更为直观。
	/home/abc/123/456   即为绝对路径，而
	~/123/456	    即为相对路径，但以上两者均表示同一个目录。
	
	（9）quit指令：
	（10）time指令：
	描述：本指令将会打印系统时间。

	（11）test指令：
	描述：本指令将会检测test后面用户所提供的表达式的真伪，并随后输出一句结果：The result is 1/0（1表示用户所提供的表达式为真，0表示用户所提供的表达式为假）.
	所提供选项：
	a. -n 检测用户所提供的字符串是否长度非0.   例：test -n string
	b. -z 检测用户所提供的字符串是否长度为0. 无例子
	c. =  检测用户所提供的字符串是否完全相同.  例子：test string1 = string2
	d. != 检测用户所提供的字符串是否不完全相同.例子：test string != string2
	e. -eq 检测用户所提供的两个整数是否相等.   例子：test 1 -eq 2
	f. -ne 检测用户所提供的两个整数是否不等.   例子：test 1 -ne 2
	g. -ge 检测用户提供的两个整数前者是否大于等于后者.
						   例子: test 1 -ge 2
	h. -gt 检测用户提供的两个整数前者是否大于后者.
						   例子：test 1 -gt 2
	i. -le 检测用户提供的两个整数前者是否小于等于后者.
						   例子：test 1 -le 2
	j. -lt 检测用户提供的两个整数前者是否小于后者.
						   例子：test 1 -lt 2
	（12）unset指令：
	描述：本指令将会把已经设定的变量从myshell中移除.
	例：abc=1
	echo $abc  #本句将会输出1
	unset abc
	echo $abc  #本句将不输出任何内容
	
	（13） umask指令：
	描述：本指令若不跟上任何信息，那么将会显示出当前设置的掩码，如果提供一个3位的8进制数，那么本指令将会修改掩码。
	名词解释：掩码。在Linux中，任何文件都有相应的权限设置，分为三类用户（文件拥有者，文件拥有者所在的用户群组，其他人），有三种权限（读，写，执行）。为了表示方便，一个文件的权限使用一个三位的8进制数表示，每一位表示这一类用户所拥有的权限，而数字的值代表此类用户的权限（如700表示文件拥有者拥有读写执行的权限，其他人毫无权限）。当创建一个新的文件的时候，系统将根据设置的掩码的取反值设置新文件的权限（比如系统默认022掩码，那么创建文件的时候系统就会根据777-022=755给文件755的权限设置）
	（14）shift指令：
	描述：系统内部已有$1-$9共计9个参数，shift指令的作用是根据用户的要求将参数左移一定位数。如shift 2将会使$3的值移至$1，$4的值将会移至$2，以此类推。被移出去的值将会丢失（如前一个例子，$1与$2的原值将会丢失），移入的值将会无值（还是前一个例子，$8与$9将会拥有一个NULL值，若尝试使用echo $8打印$8，myshell将会提示此变量无值。

第三部分 所支持的进阶操作
	前言：本章节将只讲述进阶操作的指令输入格式，具体实现机制请查阅下一章对应部分。
	（1）运行外部脚本
	描述：输入指令 myshell yourScriptName （yourScriptName处请填入你的脚本所在的绝对路径），myshell将会自动从中读取指令执行。脚本书写与交互模式下的myshell指令输入几乎一模一样，但是需要注意脚本书写时必须在最后写上quit或者exit指令，不然myshell将会卡死在脚本中。
	例子：（脚本中内容）
	pwd
	dir
	quit
	（输出）
	当前工作目录
	当前工作目录下的所有非隐藏文件
	
	（2）重定向输入输出
	描述：本部分与现行使用的bash有着细微的不同，为了方便实现，本章简化了部分bash中重定向的部分。
	关于重定向输入
		如果需要将一个输入重定向，那么需要在指令本体的最后加上（ <或者<< 重定向后的输入文件的路径）（添加语句为括号内的内容，请注意 <或<< 前后必须有空格，不然可能会产生不可预知的错误）。举例：exec /home/abc/123/a.out < /home/abc/123/inputFile （本指令意思是执行/home/abc/123/a.out，输入重定向为从/home/abc/123/inputFile中获取输入，而不是交互式输入）。
	关于重定向输出
		如果需要将一个输出重定向，那么需要在指令本体的后面根据需要加上不同的指令（请注意区别）：
		1）覆盖写，当文件不存在的时候将创建存储输出结果的文件，当文件存在的时候文件原有内容将被删除，从全新状态写入文件：
		pwd > /home/abc/123/outFile （注意 > 前后的空格）
		2）覆盖读，当文件不存在的时候将创建存储输出结果的文件，当文件存在的时候新的内容将会添加到文件末尾：
		pwd >> /home/abc/123/outFile （注意 >>  前后的空格）
	以上两个操作能够搭配使用。
	
	（3）后台运行
	描述：当一个指令在运行的时候用户将无法进行其他操作，这样将会影响用户工作效率。但是在指令的最后加上 & （注意，&的前后存在空格），指令依旧在执行，但是此时用户可以继续输入其他指令。当使用&后最直观的表现是下一次的命令提示符打印先于前一条指令的结果输出。
	pwd &

	（4）管道
	描述：本部分所使用的管道只能使用一层，无法嵌套，还请注意。
	带管道的指令分为前后两个部分，myshell规定后一项执行的指令为外部程序（包括bash自带的指令与使用者自己的外部程序，使用者需要在后项指令处自己说明外部程序的路径）。前一个指令的结果输出将代替stdin作为后一个指令的输入。所以如果后一条指令不需要stdin的输入，使用管道实际上是另一种变相调用外部程序的方式。
	pwd | /home/abc/123/whatIGot.out （本例中，whatIGot是一个需要从stdin获得输入的程序，程序的输出为获得的输入）

	（5）关于命令行提示符
	命令符提示行每次不仅会打印"myshell>"，还会打印当前所处的工作目录的绝对路径。
第四部分 myshell的实现原理
	前言：本章节为进阶用户阅读的章节，如果只是想要知道如何使用myshell的用户，那么前3部分应该能解答你的问题。
	（1）概述：
		myshell总体来说分为以下几大步骤：
		1）读取用户的输入并按照' '或者'\t'进行分词，将每一个读到的' '或者'\t'替换成'\0'，并使用一个指针数组，指针数组的每个元素均指向其中一个分词。举例说明：用户输入为echo $abc >> /home/abc/123/outFile ，那么用户输入不仅会存放在一个字符串数组中，还会有一个字符指针数组（假定数组的名字叫做parameter），parameter[0]指向"echo"，parameter[1]指向"$abc"，以此类推。原始用户的输入则会变为echo\0$abc\0>>\0/home/abc/123/outFile\0。存储原始字符串输入、存储处理后的字符串输入、存储字符指针数组的空间均由一个结构体的指针成员们管理。
		2）本步则会进行用户输入的语义分析。结构体中有一个整型的flag变量负责记录当前已经分析到的特殊操作。
		下面来看源码中的宏定义
		#define BACKGROUND 1
		#define IN_REDIRECT 2
		#define OUT_REDIRECT_OVERWRITE 4
		#define OUT_REDIRECT_ADDITION 8
		#define IS_PIPE 16
		#define FRONTGROUND 32
		比如当遇到"|"符号，语义分析函数就会将flag值与IS_PIPE执行或操作，并将结果存回flag。
		此外在本步，函数还会进行命令替换（echo指令的$abc的替换)，将会把变量名替换成对应的变量值。命令替换的具体实现方法将在下面的小节进行说明。
		3）语义分析完成后，如果没有检测到任何特殊操作标志（即flag==0），那么就将直接执行普通命令函数，进入相应的内部指令执行函数完成指令，完成后重新开始第一步（如果指令不是quit或者exit的话）;如果检测到特殊操作标志，那么myshell将会首先创建一个管道（如果本指令中存在管道操作），然后使用fork()函数创建一个新的进程，进入下一步。
		4）特殊操作的说明小节：由于在子进程中的操作并不会影响到主进程，所以本开发者采用了新开进程来处理特殊操作的方法。
		处理特殊操作的指令的大体思想可以叙述为：根据指令要求重定向（如果有的话）输入与输出的方向，然后执行内部指令函数。（详细的内容将会在后续章节中一一叙述）
	（2）命令替换的实现：
		myshell在开始运行的初始化阶段会首先建立一个单向链表，链表的每个结点的成员有变量名(char* name)，变量值(char* value)以及指向下一个结点的指针，该链表初始将会创建9个结点，名字分别为1、2、3……9,对应$1,$2,$3,$4,$5……$9。
		当myshell读到一个赋值表达式时（string1=string2，标志为含有等号），此时myshell会提取string1为newname，string2为newvalue，然后首先遍历链表，检查是否有结点的名字与newname相同，如果有相同，那么该相同结点的value值将被刷新为newvalue的内容，如果没有找到与newname名字相同的结点，那么myshell将会创建一个新的结点于链表的最后。
		当myshell进入命令替换环节的时候，myshell一旦检查到有分词存在$这个符号就会去遍历链表检查是否存在与其同名的结点，有的话则将分词替换成结点的值，没有就将$variable替换为"\0"，这样echo就会要么输出对应的值，要么输出空字符串。
	（3）管道的实现：
		在（1）小节4）部分，我们提到了根据指令要求重定向输入输出的方向。对于管道操作而言，首先myshell会使用fork()函数创建一个新的进程。
		在子进程中，myshell将原本与stdout标准输出所对应的接口转接到管道的输入口（使用dup2()函数），然后执行前段指令，执行完毕使用exit(0)退出进程;
		在父进程中，myshell再次创建一个新的子进程以来接收从管道获得的信息。在这个父进程的子进程2中，myshell将原本与stdin标准输入所对应的接口转接到管道的输出口，这样管道的输出就会代替输入作为后段指令的输入，执行完毕子进程2使用exit(0)退出，父进程使用waitpid()函数等待子进程2完成，并进行其他操作。
	（4）重定向输入输出的实现：
		实际上重定向输入输出的实现与管道操作差不多，只不过只需要创建一个子进程，打开指令中要使用的文件并转接到原先与标准输入/输出对应的接口上，然后执行指令本体即可。在本myshell中我们规定，当重定向输出与管道同时存在时，管道将退化成一个变相的外部程序执行，重定向输出将覆盖管道。
	（5）后台运行：
		myshell一检测到有后台运行标志（bg或者&）就会使用fork()函数新建一个进程，子进程中执行指令，而父进程中不再像默认一样waitpid()等待子进程结束，而是直接结束本轮循环，进入下一个循环接收新的输入。
